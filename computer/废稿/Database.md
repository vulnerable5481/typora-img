# Mysql基础篇



## 一.基础回顾



### 1.知识回顾

![image-20240330185847058](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240330185847058.png)



1.别名  使用单引号 '' 括起来，别用双引号！！字符串都用单引号?

2.去重   select distinct emp_id   加入 distinct

3.列的别名只能在 order by 之后使用，不能where 中使用

4.(not )bettwen and      (not) in

5.sql99版的 内连接 

select * 

from employ emp join department dep

on    emp.id = dep.id   join city c

on emp.address_id =  c.address_id

左外连接  右外连接

left join right join

6.select中出现的非组函数字段必须声明在group by中，反之group by中声明的字段不一定出现在select中





### 2.单行函数

**//注意:在mysql中 单行函数可以嵌套使用，但是聚合函数不可以嵌套使用  (oracle是可以嵌套使用的)**





#### 2.1数值函数



| 个人感觉常用的函数 | 用法           |
| ------------------ | -------------- |
| ABS(x)             | 返回X的绝对值  |
| MOD(x,y)           | 返回X除以Y的值 |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |
|                    |                |



| 函数                    | 用法                                       |
| ----------------------- | ------------------------------------------ |
|                         |                                            |
| SIGN(x)                 | 返回X的符号。正数返回1，负数返回-1，0返回0 |
| PI()                    | 返回圆周率的值                             |
| CEIL(x), CEILNG(x)      | 返回大于或等于某个值的最小整数             |
| FLOOR(e1,e2,e3...)      | 返回列表中的最小值                         |
| GREATEST（e1,e2,e3...） | 返回列表中的最大值                         |
|                         |                                            |
|                         |                                            |
|                         |                                            |









### 3.聚合函数













### 4.HAVING



**1.如果过滤条件中出现了聚合函数，就不能使用where,必须使用having来替换where,否则报错**

**2.having必须声明在group by 后面**

**3.实际开发中，使用having的前提:使用了group by**

**4.having和where可以一起使用,若过滤条件没有聚合函数用哪个都可以，但是推荐写在where中，因为效率高**



例子:查询部门id=10，20，30，40中最高工资大于一万的部门信息

方式一:    having 和 where 一起使用   (**推荐使用方式一，reason:效率高**)

select department_id,MAX(salary)

from department

where department_id  in (10,20,30,40)

group by department_id

having  MAX(salary) > 10000;

方式二：只使用having

select department_id,MAX(salary)

from department

group by department_id

having  MAX(salary) > 10000 and department_id  in (10,20,30,40);





### **5.sql执行语句顺序**



sql92:

```
SELECT .......
FROM ... , ... ,... , ...
WHERE 外连接条件  AND 不包含聚合函数的过滤条件
GROUP BY...,...,..
HAVING 包含聚合函数的过滤条件
ORDER BY ... (ASC/DESC)
LIMIT ...,...
```

sql99:

```
SELECT .......
FROM ... (LEFT / RIGHT)JOIN ... ON 外连接条件 JOIN ... ON 外连接条件
WHERE 不包含聚合函数的过滤条件
GROUP BY...,...,..
HAVING 包含聚合函数的过滤条件
ORDER BY ... (ASC/DESC)
LIMIT ...,...
```



**执行顺序**

- FROM ...   -> ON  ->  (LEFT / RIGHT) ->	  where -> group by  -> having  -> select  -> distinct  ->order by -> limit 

**//解惑:为什么where 的效率 高于 having ？**

**//因为:where 先过滤 然后再 分组  ,  但是having 会先分组(可能会有一些无意义的分组)**



![image-20240330200725613](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240330200725613.png)



### 6.子查询

**//注意:子查询  效率比较低，能用别的就用别的(比如使用自连接)，实在不行再用子查询**

![image-20240401201359936](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240401201359936.png)

#### 6.1 单行子查询

easy



#### 6.2 多行子查询

![image-20240401183115984](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240401183115984.png)



x = ANY (…)	c列中的值必须与集合中的一个或多个值匹配，以评估为true。
x != ANY (…)	c列中的值不能与集合中的一个或多个值匹配以评估为true。
x > ANY (…)	c列中的值必须大于要评估为true的集合中的最小值。
x < ANY (…)	c列中的值必须小于要评估为true的集合中的最大值。
x >= ANY (…)	c列中的值必须大于或等于要评估为true的集合中的最小值。
x <= ANY (…)	c列中的值必须小于或等于要评估为true的集合中的最大值。
———————————————

条件	描述
c > ALL(…)	c列中的值必须大于要评估为true的集合中的最大值。
c >= ALL(…)	c列中的值必须大于或等于要评估为true的集合中的最大值。
c < ALL(…)	c列中的值必须小于要评估为true的集合中的最小值。
c <= ALL(…)	c列中的值必须小于或等于要评估为true的集合中的最小值。
c <> ALL(…)	c列中的值不得等于要评估为true的集合中的任何值。
c = ALL(…)	c列中的值必须等于要评估为true的集合中的任何值。
———————————————















**//注意  在from中使用子查询 ，则必须给它起别名**

```
查询 平均工资最低的部门Id及其最低工资 (如果只要求查询部门id则需要最下面的两种方法)  
//题外话：如果是Oracle 直接秒了，因为Oracle允许聚合函数嵌套使用，可以直接 MIN(AVG(salary)),还得是付费！！！！！
select department_id,MIN(avg_sal)
from (
		select AVG(salary) avg_sal
        from employees
        group by department_id
	)   dept_avg_salary
	
查询 平均工资最低的部门id  
方法一
select department_id
from employees
group by department_id
having AVG(salary) = (
					select MIN(avg_sal)
                    from (
                            select AVG(salary) avg_sal
                            from employees
                            group by department_id
                          ) dept_avg_salary
					  )

方法二
select department_id
from employees
group by department_id
having AVG(salary) <= all (
		select AVG(salary) avg_sal
        from employees
        group by department_id
	)  
```



**空值问题**

```
select last_name
from employees
where employees_id not in (
							select manager_id
							from employees
							#where manager_id is not null  //如果里面有一个Null值就会导致整体查出来的为空！！！
							)							   //所以有的时候需要 注意空值问题

```

















#### 6.3 相关子查询



##### 6.3.1 一个案例

```
查询 工资大于等于 本部门平均工资 的员工信息
方式一:
select *
from employees e1
where salary >= (
				select AVG(salary)
				from employees e2
				group by department_id
				where e2.employees_id = e1.employees_id
				)
				
方式二(更常用??):
seelct *
from employees e join (
                        select department_id,AVG(salary)
                        from employees
                        group by department_id
						) t_emp_avg_sal.department_id
on e.department_id = t_emp_avg_sal.department_id
```





##### 6.3.2 EXISTS，NOT EXISTS



![image-20240401195603390](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240401195603390.png)



```
查询公司管理者的信息
方式一:自连接
select * 
from employees emp join employees mgr
on emp.employees_id = mgr.employees_id

方式二:子查询 (效率低)
select *
from employees
where employees_id in (
						select manager_id
						from employees
						)
						
方式三:EXISTS   (效率比较高)
select * 
from employees e1
where  EXISTS(
			select *
			from employees e2
			where e1.employees_id = e2.employees_id
			  ) 
			  
			  
一个别的案例
select department_id,department_name 
from employees e
WHERE NOT EXISTS(
								select *
								from department d
								where e.department_id = d.department_id 
								);

```





##### 6.3.3 相关更新

**//使用相关子查询依据一个表的数据来更新另外一个表的数据**



```
在employees中增加一个字段department_name，利用department表来填充数据

update employees e
set department_name = (
						select department_name
						from department d
						where e.department_id = department_id
						)

```



##### 6.3.4 相关删除

**//和相关更新差不多**

```
删除表employees中 与emp_history两者都有的数据
delete from employees e1
where employees_id in(
					select employees_id 
					from emp_history e2
					where e1.employees_id = e2.employees_id
						)
```

























##### 6.3.5 一些不错的案例



```sql
查询  平均工资最低的部门信息及其平均工资

SELECT d.* , (SELECT AVG(salary) FROM employees WHERE department_id = d.department_id) avg_sal
FROM department d
WHERE department_id = (
												SELECT department_id
												from employees
												GROUP BY department_id
												HAVING AVG(salary) <= ALL (
																			SELECT  AVG(salary)
																			from employees
																			GROUP BY department_id
																		 )
											);
											
			//其实还可以使用Limit								
SELECT d.* , (SELECT AVG(salary) FROM employees WHERE department_id = d.department_id) avg_sal
FROM department d
WHERE department_id = (
												SELECT department_id
												from employees
												GROUP BY department_id
												HAVING AVG(salary) <= ALL (
																			SELECT  AVG(salary) a_sal
																			from employees
																			GROUP BY department_id
                                                    						ORDER BY a_sal
                                                    						LIMIT 0,1
																		 )
											);

```







### 7.视图

**//大项目用的多，小项目用的少**

本质就是存储起来的sql语句





### 8.GLOBAL与SESSION系统变量的使用



系统变量分为全局系统变量(需要添加global关键字)和会话系统变量(需要添加session关键字)，有时把全局系统变量称为全局变量，会话变量称为Local变量。**如果不指定，默认会话级别。**

每一个Mysql客户端成功连接Mysql服务器之后，都会产生与之对应的会话。会话期间，Mysql服务实例会在Mysql服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量的复制。



![image-20240424125223015](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240424125223015.png)



- 全局系统变量针对所有会话(连接)有效，**但不能跨重启**,一旦重启就全部失效
- 会话系统变量只针对当前会话(连接)有效，连接期间修改也只改变当前会话





查看系统变量

```mysql
SHOW SESSION/GLOBAL VARIABLES; --查询全部

SHOW SESSION/GLOBAL VARIABLES LIKE '%XXX%'; --查询部分

//更常见的写法
SHOW @@session/global VARIABLES LIKE '%XXX%' --@@XXX 表示系统变量   @XX表示用户自定义变量

SHOW @@global.max_connections;   //查询指定系统变量

```



















# Mysql高级篇





## 1.linux下安装mysql8.0



**//挺麻烦的，直接去看视频，有空自己总结下来，还是很有帮助的!**









## 2.mysql8.0与5.7的一些区别和一些小知识





### 2.1字符集

**结论:mysql8.0很多重要的表默认字符集是utf8 , mysql5.7很多重要的表默认是latin**

​		**这就导致5.7如果不做修改直接添加中文会失败，而8.0则不会**

**//表的默认字符集关键就是character_set_server和character_set_database的字符集是什么,而character_set_server是数据库级别，会影响character_set_database，所以只需要修改character_set_server**



**//8.0**

![image-20240423214210994](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240423214210994.png)



**//5.7**

![image-20240423213853913](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240423213853913.png)





**在基础篇我们已经修改过，但是在linux环境下如何修改呢？**

只需要修改5.7的/etc/my.cnf,在随便位置(建议直接写在最后面)添加 character_set_server=utf8

//但是已创建的数据库(表默认跟随数据库的字符集)还是不变 

//如图所示

![image-20240423214932139](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240423214932139.png)







关于字符集的一些知识:

各级别的字符集

- 服务器级别
- 数据库级别
- 表级别
- 列级别

如果不想跟随上级的字符集，可以自己单独去修改字段之类的去操作.





### 2.2sql规范

window不区分大小写,linux表名，别名，字段名，数据库名等等一些名字会区分大小写

**//企业规范：凡是关键字;函数名称都大写，名字别名都小写;sql语句必须以分号结尾**





### 2.3sql_mode

宽松模式VS严格模式



最经典的问题

SELECT name,dep,age,MAX(salary)

FROM emp

GROUP BY dep

**select中的非聚合字段必须出现在 group by 中，还记得吗！**



**//开发中我们使用的是严格模式**



























































































# Redis基础篇

## 收获



### 1.线程池的应用

比如这个

```
private static final ExecutorService CACHE_REBUILD_EXEUTOR = Executors.newFixedThreadPool(10);
```

```
// 6.3获取成功，实现缓存重建
CACHE_REBUILD_EXEUTOR.submit(() ->{
   //重建缓存
   saveShop2Redis(id,20L);	
   //释放互斥锁
    unlock(lockKey);
});
```







### 2.给@Component传参



比如下面的代码，我以前都没想到还可以给组件传参，这样就省了很多东西，**提高复用性**

```
@Slf4j
@Component
public class CacheClient {

    private final StringRedisTemplate stringRedisTemplate;


    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }
```





### 3.自己将特定方法抽象成统一方法







### 4.位运算

​	

![image-20240412121400274](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240412121400274.png)



### 5.@Transactional



默认是只有遇见了runxxxxException才会报错







### 6.包装类与intern()



**直接上结论**：包装类型虽然值相同但是内存地址不同，所以比较的结果一定是false，如果将其.toString()也依然是不同的内存地址，但是使用.toString().intern()就可以实现值相同地址相同	(实现方式：去字符串池找如果找到一样的就直接返回)

```
@Test
void test() {
    Integer x = 1;
    Integer y = 1;
    String xx = x.toString().intern();
    String yy = y.toString().intern();
    if(xx == yy){
        System.out.println("相同");
    }else {
        System.out.println("不同");
    }
    System.out.println(1);
}
```



### 7.拆箱返回问题



    public boolean tryLock(long timeoutSec) {
        //获取线程id
        long id = Thread.currentThread().getId();
        //保存到redis
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, id + "", timeoutSec, TimeUnit.SECONDS);
    
        return Boolean.TRUE.equals(success);//注意，凡是拆箱都有可能出现空指针问题，因此建议不要直接返回拆箱结果
    }



### 8.UUID的生成时间



UUID是类初始化就已经生成好了!!!!!!!





### 9.提高效率的几个小技巧





### 10.hutool

一个万能的工具类

```
<!--hutool-->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.7.17</version>
```





### 11.lua脚本 



**//lua脚本专门解决  原子性问题**

在类路径下面编写lua脚本

```
//加载类路径下面的seckill.lua资源
private static final DefaultRedisScript SECKILL_SCRIPT;
static {
    SECKILL_SCRIPT = new DefaultRedisScript();
    SECKILL_SCRIPT.setLocation(new ClassPathResource("seckill.lua"));
    SECKILL_SCRIPT.setResultType(Long.class);
}
```

```
//2.使用lua脚本 判断用户是否具有购买资格
Long result = (Long) stringRedisTemplate.execute(
        SECKILL_SCRIPT,
        Collections.emptyList(),
        voucherId.toString(),
        userId.toString()
);
```







### 12.返回空集合

当你需要返回有个空List的时候就返回这个,同理其他空集合也各自有别的方法，直接返回Null一般是不合适的







### 13.stream流能将集合按类分组



​        Map<Long,List<Shop>> map = shops.stream().collect(Collectors.groupingBy(Shop::getTypeId));

```
    @Test
    void loadShopData() {
        //1.查询店铺信息
        List<Shop> shops = shopService.list();
        //2.将店铺按照类型分组
        Map<Long,List<Shop>> map = shops.stream().collect(Collectors.groupingBy(Shop::getTypeId));
        //3.将店铺坐标存入redis
        for(Map.Entry<Long,List<Shop>> entry : map.entrySet()) {
            //3.1获取类型Id
            Long typeId = entry.getKey();
            String key = "shop:geo:" + typeId;
            //3.2获取同类型的店铺的集合
            List<Shop> value = entry.getValue();
            //3.3写入redis GEO key 经度 纬度 member
            List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>(value.size());
            for(Shop shop : value) {
//                stringRedisTemplate.opsForGeo().add(key,new Point(shop.getX(),shop.getY()),shop.getId().toString());
//                这样一个一个存进去效率不高，所以我们选择另一种方法，也使我们之前的分组派上用场
                locations.add(new RedisGeoCommands.GeoLocation<>(
                        shop.getId().toString(),
                        new Point(shop.getX(),shop.getY())));
            }
            //这个重写版本的add，一次性添加一个集合，而不是之前那样一个一个添加，提高效率
            stringRedisTemplate.opsForGeo().add(key,locations);
        }

    }
```





### 14.日期格式化



```
LocalDateTime now = LocalDateTime.now(); // 2024-04-22T22:43:21.902337700
String result = now.format(DateTimeFormatter.ofPattern("自定义格式"));//比如 "yyyy-MMM-dd hh:mm:ss"或使用预定义的常数（如ISO_LOCAL_DATE_TIME）来格式化日期时间。   格式很自由，需要什么加什么，需要最前面加:就加，“:yyyyMM” 例子：:202404

```







## 0.初识redis







### 0.1  NoSql

**disadvantages:**	Nosql相比传统的mysql那种关系型数据库，数据结构比较松散不严格；数据无关联；语法比较松，不同的nosql数据库语法甚至都不一样；对于事务处理也只能做到一般处理

****

![image-20240320164740288](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240320164740288.png)

**advantages: **

​						查询性能高，一般都在内存中储存

​		





### 0.2linux下安装redis



```
1.下载redis-6.14xx版本  到 /usr/local/src 目录
2.下载相关依赖  yum install -y gcc tcl
3.tar -zxvf reids-6.xxxx
4.启动redis
    (1) 已经默认配置了全局变量，可以在任意位置 redis-server启动
    (2)修改配置文件: 首先备份一份redis.conf以防万一,cp redis.conf redis.conf.bck   (推荐)
    				然后   修改vim redis.conf   详情见下面
    				最后 启动时加上配置文件绝对路径(如果在reids目录下可不用加绝对路径)建议到目录下面运行
    				redis-server /usr/local/src/redis-6.xxx/redis.conf
    (3)开机自启动:
```





![image-20240402151727157](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402151727157.png)







### 0.3使用redis





```
1.命令行使用redis：进入cd /usr/local/bin
					redis-cli -h 当前ip/127.0.0.1 -p 6379 -a 密码 (这样是危险的)
			建议:    redis-cli -h 127.0.0.1 -p 6379
					AUTH 密码
					输入ping 
					回复pong 即成功！！
2.redis图形化操作:  https://github.com/lework/RedisDesktopManager-Windows/releases 下载
					要使用别忘了关闭防火墙



```



### 0.4  Redis是单线程的！！！！











## 1.redis基础



### 1.0 reids 通用操作

```
KEYS :  查看符合模板的所有key   keys a*  不建议在生产环境使用,效率可能比较低

DEL :   例子 DEL k1 k2 k3 k4   ,返回值为删除的数量 如果k4不存在，则返回3,表示删除了三个数据

EXISTS:  EXISTS K1  存在返回1，不存在返回0

expire: 给一个key设置有效期   expire key seconds           
 					-1 表示永久有效  -2 表示已经失效
TTL : 查看一个key的剩余有效期
```











### 1.1 redis的数据类型

![image-20240402162348526](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402162348526.png)



#### 1.1.1String类型



```
1.SET  :  会覆盖哦        //可以在后面加很多东西  set name jack ex 100(设置name有效期为100秒)
 											 set name jack nx == setnx name jack
2.GET

3.MSET :批量set   mset k1 v1 k2 v2 k3 v3

4.MGET :批量get   mget name age k1 k2 k3

5.INCR :自增长  set age 12; incr age ; get age /age = 13

6.INCRBY :自增长 by 整数   incrby age 3 ;

7.INCRBYFLOAT: 子增长 by 浮点数

8.DECR: 自减少

9.SETNX : 如果key不存在则生成，若存在则set失败  //底层是 set k v nx ，其实是set和nx两个组合使用，set 后面可以跟很多东西
```



![image-20240402164344125](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402164344125.png)







#### 1.1.2Hash类型



```
1.HSET:   hset student name jack age 12 skill study

2.HGET: hget student name 

3.MGET: mget user:student:1 name age skill

4.hgetall

5.hkeys

6.hvalues

7.hincrby

8.hsetnx
```

在 Redis 中可以通过 setex 或 expire 方式来设置 key 的过期时间。但是对于Hash 数据类型 Redis 是不支持的，所以我们需要使用“曲线救国”的方式去实现 Hash 数据类型的过期时间。

即，先对 Hash 数据类型赋值，然后再对 Hash 数据类型的 key 设置一个过期时间，这样就间接的实现了对 Hash 数据类型的过期时间操作。






#### 1.1.3List类型



![image-20240402170557754](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402170557754.png)q

```
1.LPUSH key element
  RPUSH key element

2.LPOP key  移除左侧第一个元素，若没有则返回nil
  RPOP key

3.LRANGE key star end 

4.BLPOP   和lpop rpop 的区别就是 blpop 不会直接返回nil 而是在没有元素时等待指定时间
  BRPOP

```







#### 1.1.4Set类型



![image-20240402180625576](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402180625576.png)



```
1. SADD key element1 element2 ...

2.SREM key emlement1 element2 ...

3.SCARD key: 返回set中元素的个数

4.sismember key member: 判断存在

5.smembers key: 获取set中所有元素

6.sinter k1 k2 ：交集
  sdiff k1 k2 :差集
  sunion k1 k2:并集
```







#### 1.1.5SortedSet类型



![image-20240402181751599](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402181751599.png)

**sortedset 默认是升序**

```
1.ZADD key score1 member1 score2 member2 ...

2.ZREM key member1

3.ZSCORE key member1

4.zrank key member   //注意是从0开始计算的

5.zcard key  返回sortedset中元素的个数

6.zcount key score_min score_max   查询min - max 区间 元素个数

7.zrange key index_min index_max   正序查询 min - max 的元素信息
  zrevrange key index_min index_max 倒序查询 min - max 的元素信息

8.zrangebyscore key score_min score_max  注意两边是开区间
 
9.zincrby key 整数 member

10. zdiff zinter zunion
```









### 2.redis的Java客户端





#### 2.0 三种常用，一个整合

![image-20240402213101169](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402213101169.png)







#### 2.1 jedis



![image-20240402213619285](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402213619285.png)



**//如果真的要使用jedis，也得用jedis线程池，怎么写自己去搜**







####   2.2StringDataRedis







![image-20240402220350324](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240402220350324.png)



##### 2.2.1   依赖问题

引入依赖   lettue有问题，暂时别引入

```
<!--        redis-依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <version>2.7.3</version>
        </dependency>
<!--        lettue 缓存连接池-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
            <version>2.7.3</version>
        </dependency>
```





##### 2.2.2 序列化问题



因为redis底层都是将Java传过来的对象进行字节处理，序列化，这就导致数据库那边变成乱码



![image-20240403122127294](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240403122127294.png)





//解决方法 :

**//注意  实际开发中，我们一般不需要查看value,所以一般都是只需要设置key的序列化工具即可**

```
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){
        //创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        //设置连接工厂
        template.setConnectionFactory(redisConnectionFactory);
        //创建json序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        //设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        //设置value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        //返回
        return template;
    }
}
```



**一个小疑问: RedisSerializer.String() 与 new StringSerializer()的区别**

解答;其实没有区别，你看源码，new StringSerializer()默认也是utf-8，直接RedisSerializer.String()也是返回utf-8的StringSerializer

```
static RedisSerializer<String> string() {
    return StringRedisSerializer.UTF_8;
}
```



**//小细节;ctrl + h 可以查看实现类**

![image-20240403130542313](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240403130542313.png)













##### 2.2.3 StringRedisTemplate



![image-20240403132307534](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240403132307534.png)

![image-20240403132324634](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240403132324634.png)



![image-20240403132348437](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240403132348437.png)







使用案例

**//没什么特别的，唯一需要注意的是需要你手动序列化，你可以使用jackson,gson,fastjson，随便，用哪个就去现学呗，都是api**



```java
@SpringBootTest
public class TestRedis {
    @Resource
    private RedisTemplate redisTemplate;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    private static final ObjectMapper mapper = new ObjectMapper();

    @Test
    void aa(){
        String json = null;
        //创建对象
        Student student = new Student("李元霸", 20, "举重");
        //手动序列化
        try {
            json = mapper.writeValueAsString(student);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        stringRedisTemplate.opsForValue().set("user:student:5",json);

        //取出数据
        String s = stringRedisTemplate.opsForValue().get("user:student:5");
        Student student1 = null;
        try {
            student1 = mapper.readValue(s, Student.class);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        System.out.println(student1);
    }
}
```





![image-20240403134306803](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240403134306803.png)

















## 2.redis实战篇之商户查询





### 2.1 hmdp之实现短信验证功能



![image-20240407175200237](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240407175200237.png)





- 隐藏用户敏感信息，不要直接将一个user存到threadlocal里面，可以存一个userDTO
- 一个问题:如何实现一个真实的短信发送功能呢?



### 2.2缓存更新



![image-20240410123641028](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410123641028.png)





**缓存更新策略的最佳实践方案:**

​											1.低一致性需求：使用redis自带的**内存淘汰**机制

​											2.高一致性需求："**主动更新**"(程序员自己在程序中添加更新/删除缓存的操作),并以"**超时剔除**"兜底

​												读操作：缓存命中直接返回；缓存未命中则查询数据库，写入缓存，设置TTL超时时间

​												写操作：先写数据库，然后删除缓存，确保数据库和缓存操作的原子性







![image-20240410125548090](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410125548090.png)

![image-20240410125525968](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410125525968.png)







### 2.3缓存穿透

![image-20240410132556671](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410132556671.png)



![image-20240410182015564](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410182015564.png)



![image-20240410181852339](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410181852339.png)







### 2.4缓存雪崩



![image-20240410205400497](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410205400497.png)









### 2.5缓存击穿



**//concept:**

![image-20240410210250457](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410210250457.png)

 

**//solution:**

![image-20240410210223055](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410210223055.png)



**//advantage and disadvantage**

![image-20240410210511769](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240410210511769.png)



互斥锁

![image-20240411122356869](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240411122356869.png)



逻辑过期

![image-20240411134514875](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240411134514875.png)









## 3.redis实战篇之优惠券秒杀





### 3.1 全局Id生成器（利用redis生成）





```
@Component
public class RedisIdWorker {

    /*
    * 开始时间
    * */
    private static final long BEGIN_TIMESTAMP = 1712923032L;
    /*
    * 序列号的位数
    * */
    private static final long COUNT_BITS = 32;

    private StringRedisTemplate stringRedisTemplate;

    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }


    public long nextId(String keyPrefix) {
        //1.生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timeStamp = nowSecond - BEGIN_TIMESTAMP;

        //2.生成序列号
        //2.1获取当前日期，精确到天       //这样有什么好处？解答：可以精确统计每一天/月/年的订单量； 也可以防止key一直增长到最大导致超出范围
        String date = now.format(DateTimeFormatter.ofPattern("yyyMMdd"));
        Long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        //3.拼接并返回
        return timeStamp << COUNT_BITS | count;
    }

}
```



//这里巧妙利用 位运算

![image-20240412121325533](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240412121325533.png)





![image-20240412123239315](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240412123239315.png)









### 3.2 优惠券秒杀之单体应用版本的一人一单



![image-20240412204042917](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240412204042917.png)









![image-20240412210723107](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240412210723107.png) 	![image-20240412211423379](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240412211423379.png)





**//CAS乐观锁**



```
//4.扣除秒杀券
boolean success = seckillVoucherService.update()
        .setSql("stock = stock - 1")//set stock = stock - 1
        //cds实现乐观锁
        .eq("voucher_id", voucherId).gt("stock", 0)//where user_id=? and stock>0
        .update();
if(!success) {
    //扣减失败
    return Result.fail("VOUCHER_IS_OVER");
}
```





**//悲观锁**

没有选择直接将锁加在整个方法，是因为那样会串行执行，效率很低，将锁加在user_id，效率就高很多

注意一个地方，就是user_id是Long包装类型，即使传过来的值一样，但是底层仍然会new一个新对象，所以我们采取.toString方法将其变成String类型,再使用.instern()使其从字符串池中获取。



**//一些并发问题，这里我们将创建秒杀券抽出成一个方法，但是加上事务管理，使用悲观锁锁上user_id，但是依然无法解决并发问题,这是因为Spring管理的事务提交好像不是很块，在你执行完方法后，可能还没有提交事务,这时候已经释放锁了，导致并发问题**

```
/*
* 创建秒杀券
* */
    @Transactional
    public Result createVoucherOrder(Long voucherId,Long user_id) {
            //4.判断用户是否重复购买
            //查询订单
            Integer count = query().eq("user_id", user_id).eq("voucher_id", voucherId).count();
            if (count > 0) {
                //该用户重复购买，返回错误信息
                return Result.fail(VOUCHER_USER_IS_TWICE);
            }
            //5.扣除秒杀券
            boolean success = seckillVoucherService.update()
                    .setSql("stock = stock - 1")//set stock = stock - 1
                    //cds实现乐观锁
                    .eq("voucher_id", voucherId).gt("stock", 0)//where user_id=? and stock>0
                    .update();
            if(!success) {
                //扣减失败
                return Result.fail("VOUCHER_IS_OVER");
            }
            //6.下单
            VoucherOrder voucherOrder = new VoucherOrder();
            //订单Id
            long orderId = redisIdWorker.nextId("order");
            voucherOrder.setId(orderId);
            //代金券Id
            voucherOrder.setVoucherId(voucherId);
            //用户Id
            voucherOrder.setUserId(user_id);
            //生成订单
            save(voucherOrder);

            //7.返回订单Id
            return Result.ok(orderId);
    }
}
```



### 3.3优惠券秒杀之分布式锁



#### 问题的引出

**//由于开启了多个服务器，每个服务器的JVM都是独立的，导致之前锁上的user_id通过toString().intern()从字符串常量池获取来辨别的方式失效!!!**

![image-20240415145923311](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240415145923311.png)



#### 什么是分布式锁？

![image-20240415150651244](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240415150651244.png)

#### 分布式锁的多种实现

![image-20240415151258368](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240415151258368.png)







#### Redis实现分布式锁版本1

```
public class SimpleRedisLock {
    //不同业务 有不同的名称
    private String name;
    //前缀
    private static final String KEY_PREFIX = "lock:";
    private StringRedisTemplate stringRedisTemplate;

    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /*
    * 获取锁
    * */
    public boolean tryLock(long timeoutSec) {
        //获取线程id
        long id = Thread.currentThread().getId();
        //保存到redis
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, id + "", timeoutSec, TimeUnit.SECONDS);

        return Boolean.TRUE.equals(success);//注意，凡是拆箱都有可能出现空指针问题，因此建议不要直接返回拆箱结果
    }
    /*
    * 释放锁
    * */
    public void unLock() {
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}
```



#### Redis实现分布式锁版本2

**解决极小概论事件：如果JVM1的线程1发送阻塞，超时删除锁，JVM2的线程2这时刚好获取锁，JVM1的线程1阻塞结束，就删除锁，这时就陷入到有线程还在继续业务，但是锁已经被释放！！（不过应该是比较小概率吧）**

**//UUID是类初始化就已经生成好了!!!!!!!**

**//uuid 是用来区分在不同JVM中的相同线程id的，如果是单服务器下直接用线程id区分，但是如果是集群那么还需要用uuid标识线程id是来自不同的集群**

```
public class SimpleRedisLock {
    //不同业务 有不同的名称
    private String name;
    //前缀
    private static final String KEY_PREFIX = "lock:";
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    private StringRedisTemplate stringRedisTemplate;

    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /*
    * 获取锁
    * */
    public boolean tryLock(long timeoutSec) {
        //获取线程id
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        //保存到redis
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);

        return Boolean.TRUE.equals(success);//注意，凡是拆箱都有可能出现空指针问题，因此建议不要直接返回拆箱结果
    }
    /*
    * 释放锁
    * */
    public void unLock() {
        // 获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 获取锁中的标识
        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
        // 判读标识是否一致
        if(threadId.equals(id)) {
            //释放锁
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }
    }
}
```





#### Redis实现分布式锁版本3

**//如何实现释放锁的原子性?**

**//这里我们使用lua脚本，因为lua脚本里面的代码是具有原子性的**

**//一个极端情况：在我们判断完锁标识之后，即将进行释放锁之前，阻塞了（比如因为JVM的垃圾回收机制）导致超时释放锁，此时刚好别的线程获取锁就会出问题**

![image-20240415185115809](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240415185115809.png)

**//解决方案：使用lua脚本**

```
public class SimpleRedisLock {
    //不同业务 有不同的名称
    private String name;
    //前缀
    private static final String KEY_PREFIX = "lock:";
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;//ctrl+h 查看继承实现关系你就知道为什么了
    //之所以使用静态代码块，是因为需要在new 对象的时候添加逻辑(就是设置一些东西)
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));//todo new ClassPathResource
        UNLOCK_SCRIPT.setResultType(Long.class);
    }
    private StringRedisTemplate stringRedisTemplate;

    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /*
    * 获取锁
    * */
    public boolean tryLock(long timeoutSec) {
        //获取线程id
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        //保存到redis
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);

        return Boolean.TRUE.equals(success);//注意，凡是拆箱都有可能出现空指针问题，因此建议不要直接返回拆箱结果
    }
    /*
    * 释放锁
    * */
    public void unLock() {
//        // 获取线程标识
//        String threadId = ID_PREFIX + Thread.currentThread().getId();
//        // 获取锁中的标识
//        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
//        // 判读标识是否一致
//        if (threadId.equals(id)) {
//            //释放锁
//            stringRedisTemplate.delete(KEY_PREFIX + name);
//        }
        ArrayList<String> keys = new ArrayList<>();
        keys.add(KEY_PREFIX + name);
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,//提前将要读取的文件整合到RedisScript类中，这样就不需要每次使用该方法都读取了！！！！
                keys,
                ID_PREFIX + Thread.currentThread().getId());
    }
}
```



"unlock.lua" 位置直接放在resource下面,关于lua编程感觉和linux的shell编程差不多，用到什么直接去查就完事了

```
-- 获取锁的线程标识
local id = redis.call('get',KEYS[1])
--判断两者是否一致
if(id == ARGV[1])
then
    --一致则释放锁
    return redis.call('del',KEYS[1])
end
--不一致就退出
return 0
```















### 3.4 Redisson

**//前面我们自己设计了一个SimpleRedisLock，用来解决分布式线程问题，但是自己实现有很多缺点而且比较麻烦，这里我们推荐使用redisson来直接获取锁**



#### 3.4.1 快速入门

1.引入依赖（好像这个依赖不好，以后使用到的时候自己去研究一下）：

```
<!--        redisson-->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.13.6</version>
        </dependency>
```

2.配置类/配置文件(配置文件还没有使用过)：

```
@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redissonClient(){
        //配置类
        Config config = new Config();
        //配置单点对象,config.useClusterServers()是配置集群
        config.useSingleServer().setAddress("redis://192.168.200.130:6379").setPassword("1674472827");
        //返回
        return Redisson.create(config);
    }
}
```



3.使用redissonClient



```
Rlock lock = redissonClient.getLock(key);获取锁
boolean success = lock.trylock()//尝试获取锁,可以有参 lock.trylock(1,10,TIME.SECONDS)，1应该是表示启用吧
lock.unlock()//释放锁


```





#### 3.4.2 原理





![image-20240416133122091](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240416133122091.png)





#### 3.4.3 可重入的Redis分布式锁

**//同一个线程无法多次获取同一把锁，比如我们的购买秒杀券，确实需要同一个线程不能获取同一把锁，但是有的业务需要同一个线程多次获取同一把锁，来进行操作，这个我们自己设计锁的时候可以使用hash，存一个key,filed,value，其中key和filed不变依然是local:业务Name  +  uuid:id，维护一个value当作计数器，获取一次锁就++，结束一个业务就--，直到所有业务都结束，当value = 0就释放锁.**//以上操作可以使用lua脚本实现，确保原子性，实际上redisson底层就是使用lua脚本完成



![image-20240416133643515](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240416133643515.png)



![image-20240416133654249](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240416133654249.png)









![image-20240416155433658](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240416155433658.png)









### 3.5优惠券秒杀之异步优化



#### 3.5.0 老代码

```java
@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {

    @Resource
    private ISeckillVoucherService seckillVoucherService;

    //全局id
    @Resource
    private RedisIdWorker redisIdWorker;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /*
    * 购买秒杀券
    * */
    @Override
    public Result buySeckillVoucher(Long voucherId) {
        //1.根据Id查询秒杀券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
           //如果为空，返回错误
           return Result.fail(VOUCHER_IS_NULL);
        }
    	//2.判断当前时间是否允许购买
        LocalDateTime now = LocalDateTime.now();
        if(now.isBefore(seckillVoucher.getBeginTime()) || now.isAfter(seckillVoucher.getEndTime())) {
            return Result.fail(VOUCHER_IS_NOT_IN_TIME);
        }
        //3.判断秒杀券是否剩余
    	if(seckillVoucher.getStock() < 1) {
            return Result.fail(VOUCHER_IS_OVER);
        }

        Long userId = UserHolder.getUser().getId();
        if (userId == null) {
            userId = 1L;
        }

        //创建锁对象
        RLock lock = redissonClient.getLock("lock:order:" + userId);
        //获取锁
        boolean success = lock.tryLock();//无参，失败不等待
        if(!success) {
            //获取失败
            return Result.fail(VOUCHER_USER_IS_TWICE);
        }
        try {
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId,userId);
        } finally {
            //释放锁
            lock.unlock();
        }

    }

    /*
    * 创建秒杀券
    * */
    @Transactional
    public Result createVoucherOrder(Long voucherId,Long user_id) {
            //4.判断用户是否重复购买
            //查询订单
            Integer count = query().eq("user_id", user_id).eq("voucher_id", voucherId).count();
            if (count > 0) {
                //该用户重复购买，返回错误信息
                return Result.fail(VOUCHER_USER_IS_TWICE);
            }
            //5.扣除秒杀券
            boolean success = seckillVoucherService.update()
                    .setSql("stock = stock - 1")//set stock = stock - 1
                    //cds实现乐观锁
                    .eq("voucher_id", voucherId).gt("stock", 0)//where user_id=? and stock>0
                    .update();
            if(!success) {
                //扣减失败
                return Result.fail("VOUCHER_IS_OVER");
            }
            //6.下单
            VoucherOrder voucherOrder = new VoucherOrder();
            //订单Id
            long orderId = redisIdWorker.nextId("order");
            voucherOrder.setId(orderId);
            //代金券Id
            voucherOrder.setVoucherId(voucherId);
            //用户Id
            voucherOrder.setUserId(user_id);
            //生成订单
            save(voucherOrder);

            //7.返回订单Id
            return Result.ok(orderId);
    }
}
```









#### 3.5.1为什么需要优化以及优化思路

![image-20240419115723204](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240419115723204.png)

​	

![image-20240419122539513](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240419122539513.png)



#### 3.5.2 基于redis实现消息队列



**//消息队列还是有空专门学习redisMQ吧，这里就不学了，听得有点烦躁**



​	



## 4.基础功能实现





### 4.1发布博客

自己去看代码，这里图片是直接保存到了本地，也可以使用阿里云OSS





### 4.2点赞与点赞排行

利用redis中的sortedset





### 4.3共同关注

使用了redis的set中交集

```
Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);
```









## 5.Feed流(关注推送)





### 5.1什么是Feed流

![image-20240422155318827](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422155318827.png)



![image-20240422155345247](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422155345247.png)

### 5.2 实现TimeLine的三种模式

**这里我们学习简单的TimeLine模式，但是timeline也有三种实现模式**





![image-20240422155510503](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422155510503.png)



![image-20240422155522332](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422155522332.png)

![image-20240422160000539](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422160000539.png)

![image-20240422160011503](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422160011503.png)



  





## 6.GEO(附近店铺)





**//redis中提供了一个GEO数据结构，专门用来代表地理坐标，其实底层是用sortedset存储的**

![image-20240422195716182](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422195716182.png)



将数据库中的店铺的x,y存入到redis中

```
    @Test
    void loadShopData() {
        //1.查询店铺信息
        List<Shop> shops = shopService.list();
        //2.将店铺按照类型分组
        Map<Long,List<Shop>> map = shops.stream().collect(Collectors.groupingBy(Shop::getTypeId));
        //3.将店铺坐标存入redis
        for(Map.Entry<Long,List<Shop>> entry : map.entrySet()) {
            //3.1获取类型Id
            Long typeId = entry.getKey();
            String key = "shop:geo:" + typeId;
            //3.2获取同类型的店铺的集合
            List<Shop> value = entry.getValue();
            //3.3写入redis GEO key 经度 纬度 member
            List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>(value.size());
            for(Shop shop : value) {
//                stringRedisTemplate.opsForGeo().add(key,new Point(shop.getX(),shop.getY()),shop.getId().toString());
//                这样一个一个存进去效率不高，所以我们选择另一种方法，也使我们之前的分组派上用场
                locations.add(new RedisGeoCommands.GeoLocation<>(
                        shop.getId().toString(),
                        new Point(shop.getX(),shop.getY())));
            }
            //这个重写版本的add，一次性添加一个集合，而不是之前那样一个一个添加，提高效率
            stringRedisTemplate.opsForGeo().add(key,locations);
        }

    }
```









## 7.BitMap(用户签到)



### 7.1什么是BitMap?

**//重要思想：利用二进制中的0和1统计或计算或完成某些功能的思想，就是位图(BitMap)**

**//redis中使用String类型实现bitmap**

![image-20240422220640253](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422220640253.png)

![image-20240422221003372](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422221003372.png)



![](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422220853001.png)

```\
setbit group1 0 1
bitfiled group1 u2 0 //u2: u是无符号，2是查找几位，0是从下标0开始查,返回的是十进制，比如0011  返回的就是3 （8421法）
bitfiled group1 u4 0 //比如11011 返回的是13
u是无符号,i是有符号
```



![image-20240422222743602](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240422222743602.png)











### 7.2 实现签到



利用redis的bitmap实现签到

```
@Override
public Result sign() {
    //1.取出当前用户
    Long userId = UserHolder.getUser().getId();
    //2.获取日期
    LocalDateTime now = LocalDateTime.now();
    //3.拼接key
    String keySuffix = now.format(DateTimeFormatter.ofPattern(":yyyyMM"));
    String key = "sign:" + userId + keySuffix;
    //4.获取今天是第几天
    int dayOfMonth = now.getDayOfMonth();
    //5.写入redis
    //dayOfMonth因为下标从0开始要-1；true意思是用1占位，false用0占位
    stringRedisTemplate.opsForValue().setBit(key,dayOfMonth - 1,true);
    //6.返回
    return Result.ok();
}
```







### 7.3统计连续签到天数	



```
    // 1.获取当前登录用户
    Long userId = UserHolder.getUser().getId();
    // 2.获取日期
    LocalDateTime now = LocalDateTime.now();
    // 3.拼接key
    String keySuffix = now.format(DateTimeFormatter.ofPattern(":yyyyMM"));
    String key = USER_SIGN_KEY + userId + keySuffix;
    // 4.获取今天是本月的第几天
    int dayOfMonth = now.getDayOfMonth();
    // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0
    List<Long> result = stringRedisTemplate.opsForValue().bitField(
            key,
            BitFieldSubCommands.create()
                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)
    );
    if (result == null || result.isEmpty()) {
        // 没有任何签到结果
        return Result.ok(0);
    }
    Long num = result.get(0);
    if (num == null || num == 0) {
        return Result.ok(0);
    }
    // 6.循环遍历
    int count = 0;
    while (true) {
        // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0
        if ((num & 1) == 0) {
            // 如果为0，说明未签到，结束
            break;
        }else {
            // 如果不为0，说明已签到，计数器+1
            count++;
        }
        // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位
        num >>>= 1;
    }
    return Result.ok(count);
}
```









## 8.HyperLogLog



### 8.1什么是hyperloglog?

![image-20240423181817874](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240423181817874.png)	



**//HyperLogLog 非常适合用来计算 UV**

```
PFADD name e1 e2 e3 ....//添加  注意hyperloglog重复元素只会添加一次

PFCOUNT name //统计数量

```



**所以UV统计没什么难度，很简单!**







## 





# Redis高级篇





## 0.单点redis的问题

![image-20240423192315277](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20240423192315277.png)



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































