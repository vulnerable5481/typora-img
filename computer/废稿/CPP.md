

## 一.基础知识的异

### 1.基础知识与收获

#### 1.一些词

- 预处理器  --{#include , #define ....}
- 

#### 2.一些需要修正的习惯

- use const instead of #define

D







#### 3.一些不知道的知识点

- 为什么不需要引用string头文件就可以使用 string类？ anser: 因为string类在名称空间std里面.//string a = "aaa" int length = a.size()

- c++11 大括号初始化

- 共用体

- int* 是一种 类型：指向Int的指针

- 常规声明变量 是在栈中开辟内存空间，new 则是在堆或自由存储区的内存区域分配空间

- new 与delete 的匹配使用 ,对空指针使用delete 是安全的,不delete可能造成内存泄漏，动态数组(delete []  xx;)方块意思是释放整个数组的内存. 

- vector 是动态数组的替代品(堆)，array是静态数组的替代品(栈)

- const int * p :指针指向的值不可以改；int* const p:指针指向的方向不可以改.

- 引用:给变量起别名,语法：数据类型 &xx =  xx;  int &a = b;  注意事项:引用必须初始化;引用一旦初始化就不跨行业更改
  作用:引用可以用于函数传参.(如果你讨厌指针传参就可以使用引用);本质:引用本质是指针常量，比如int& a = b;相当于int* const a=&b 

- 函数参数可以有默认值,Java不支持这种特性.比如 int add(int a=10,int b);

  

### 2.C++的OOP

#### 1.封装

和Java差不多吧，get set什么的

#### 2.类与对象

就只有语法不同

**构造函数，析构函数，拷贝函数**

- 构造函数就是Java的构造器

- 析构函数在对象实例被销毁的时候会自动自动调用,一般用于delete 你new的东西

- 拷贝函数就用来拷贝：深拷贝和浅拷贝,系统提供的默认拷贝就是浅拷贝会造成重复释放堆区内存的问题.用深拷贝解决
  ![image-20231221153538787](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20231221153538787.png)

- 静态变量：1.所有对象共享2.编译阶段就分配空间3.类内声明，类外初始化操作
   可以通过命名空间实现像Java那样直接调用而不用生成实例

  静态成员变量的内存空间不算在类对象上.(只有成员变量属于类对象上，什么静态不静态的方法都不属于类对象)
  比如一个class Person里面有个public : static int heigh,需要在类外进行初始化操作
  ![image-20231221154748722](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20231221154748722.png)

- 静态成员函数
  和Java一样只能访问静态成员属性,可以通过命名空间实现像Java那样直接调用而不用生成实例
  ![image-20231221155321343](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20231221155321343.png)

- 友元函数

  **友元的作用**是**提高了程序的运行效率**（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。
  如果name 是一个private属性 ，外部有一个方法想要获取你的私有属性，则可以使用friend关键字
  这样这个函数就叫做友元函数,可以获取这个类的私有属性![image-20231221161423096](C:\Users\赵联城\AppData\Roaming\Typora\typora-user-images\image-20231221161423096.png)

- 友元类 
  和友元函数差不多一个意思   使用友元类时注意：
           (1) 友元关系不能被继承。 
           (2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
           (3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

  



#### 3.继承

**与Java的区别：**

- **一个类能同时继承多个类**

- **子类是不会继承父类的构造方法的!!!!**



**C++实际开发中不建议多继承!!!!!**



**三种继承方法:私有继承，公有继承，保护继承.**



**如果想通过子类对象访问父类对象的属性或函数(加个命名空间即可):**

- cout << "Son 下的 int a = " << s.a << endl;
- cout << "Father 下的 int a =" <<s.Father::a << endl;
  函数同理,加个作用域即可.



**虚继承**





#### 4.多态



**和Java有很多不一样的哦**



- ****

  **一个Animal父类一个Dog子类，父类有一个cry()子类也有一个cry()**

  Dog dog;
  dog.cry();//那么就是狗在叫
  **但是如果是在一个方法里面，传入一个参数比如Animal& animal，那么方法中animal.cry()就会是父类的cry而不是子类的cry()!!!!!这在Java中是相反的!!!**
  **原因：(地址早绑定)早在编译阶段就anmal.cry()就已经确认了函数地址**
  **解决方法:（虚函数）在函数前加一个关键字 virtual**





































































